{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions = {}) {\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n  async sendRequest(request) {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    const span = this.tryCreateSpan(request);\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n  tryCreateSpan(request) {\n    var _a;\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      });\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}","map":{"version":3,"names":["BaseRequestPolicy","SpanKind","SpanStatusCode","createSpanFunction","getTraceParentHeader","isSpanContextValid","logger","createSpan","packagePrefix","namespace","tracingPolicy","tracingOptions","create","nextPolicy","options","TracingPolicy","constructor","userAgent","sendRequest","request","tracingContext","_nextPolicy","span","tryCreateSpan","response","tryProcessResponse","err","tryProcessError","method","spanOptions","Object","assign","kind","CLIENT","isRecording","end","undefined","namespaceFromContext","_a","getValue","Symbol","for","setAttribute","setAttributes","url","requestId","spanContext","traceParentHeader","headers","set","traceState","serialize","error","warning","message","setStatus","code","ERROR","statusCode","status","serviceRequestId","get","OK"],"sources":["C:\\Users\\leoda\\OneDrive\\Documents\\GitHub\\PostHeart-Frontend\\node_modules\\@azure\\core-http\\src\\policies\\tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  createSpanFunction,\n  getTraceParentHeader,\n  isSpanContextValid,\n} from \"@azure/core-tracing\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { logger } from \"../log\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\",\n});\n\n/**\n * Options to customize the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * User agent used to better identify the outgoing requests traced by the tracing policy.\n   */\n  userAgent?: string;\n}\n\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions: TracingPolicyOptions = {}): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    },\n  };\n}\n\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  private userAgent?: string;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    tracingOptions: TracingPolicyOptions\n  ) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  public async sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    const span = this.tryCreateSpan(request);\n\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err: any) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n\n  tryCreateSpan(request: WebResourceLike): Span | undefined {\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const { span } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: {\n            ...(request as any).spanOptions,\n            kind: SpanKind.CLIENT,\n          },\n          tracingContext: request.tracingContext,\n        },\n      });\n\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = request.tracingContext?.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId,\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error: any) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  private tryProcessError(span: Span, err: any): void {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  private tryProcessResponse(span: Span, response: HttpOperationResponse): void {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK,\n      });\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}